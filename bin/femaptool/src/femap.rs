use std::{collections::HashSet, path::Path};

use anyhow::{anyhow, bail, Result};

use gbalz77::{compress, CompressionStrategy};

#[derive(Clone, Copy, Debug)]
pub struct Tile(u16);

impl Tile {
    pub fn new(v: u16) -> Self {
        Self(v)
    }

    pub fn render(&self) -> String {
        format!("{:#x}", self.0)
    }
}

#[derive(Debug, Clone, Default)]
pub struct Properties {
    pub chapter_id: Option<String>,
    pub map_changes_id: Option<String>,
    pub obj1: Option<String>,
    pub obj2: Option<String>,
    pub palette_id: Option<String>,
    pub tileconfig: Option<String>,
    pub map_id: Option<String>,
    pub anims1: Option<String>,
    pub anims2: Option<String>,
}

static CHAPTER_ID_ALIASES: &[&'static str] =
    &["chapter_id", "chapterid", "chapter"];
static MAP_CHANGES_ID_ALIASES: &[&'static str] = &[
    "mapchangesid",
    "map_changes_id",
    "map_changes",
    "mapchanges",
];
static OBJ1_ALIASES: &[&'static str] = &[
    "objecttype1",
    "obj1",
    "object_type_1",
    "obj_type_1",
    // In FE8, obj2 doesn't exist, so we also accept a bare `obj`.
    "objecttype",
    "objtype",
    "object_type",
    "obj",
];
static OBJ2_ALIASES: &[&'static str] =
    &["objecttype2", "obj2", "object_type_2", "obj_type_2"];
static PALETTE_ALIASES: &[&'static str] = &[
    "palette",
    "palette_id",
    "paletteid",
    "pal",
    "pal_id",
    "palid",
];
static TILECONFIG_ALIASES: &[&'static str] = &["tile_config", "tileconfig"];
static MAPID_ALIASES: &[&'static str] = &["mapid", "map_id"];
static ANIMS1_ALIASES: &[&'static str] = &["anims1", "anim1"];
static ANIMS2_ALIASES: &[&'static str] = &["anims2", "anim2"];

static MAP2EA_HEADER_LINES: &[&'static str] = &[
    "// installer generated by map2ea",
    "",
    "#ifndef MAP2EA",
    "#define MAP2EA",
    "#ifndef ChapterDataTable",
    "  #ifdef _FE7_",
    "    #define ChapterDataTable 0xC9A200",
    "    #define ChapterDataTableEntSize 152",
    "  #endif",
    "  #ifdef _FE8_",
    "    #define ChapterDataTable 0x8B0890",
    "    #define ChapterDataTableEntSize 148",
    "  #endif",
    "#endif",
];

impl Properties {
    pub fn populate_from(
        &mut self,
        entries: impl Iterator<Item = (String, String)>,
    ) -> Result<()> {
        // CR-someday cam: We should be able to derive this from the struct
        // definition and list of aliases.
        for (k, v) in entries {
            // CR-someday cam: more informative error message?
            if CHAPTER_ID_ALIASES
                .iter()
                .any(|alias| &k.to_lowercase() == alias)
            {
                if matches!(self.chapter_id, Some(_)) {
                    bail!("ChapterID is set twice")
                }
                self.chapter_id = Some(v.to_string())
            }
            if MAP_CHANGES_ID_ALIASES
                .iter()
                .any(|alias| &k.to_lowercase() == alias)
            {
                if matches!(self.map_changes_id, Some(_)) {
                    bail!("MapChangesID is set twice")
                }
                self.map_changes_id = Some(v.to_string())
            }
            if OBJ1_ALIASES.iter().any(|alias| &k.to_lowercase() == alias) {
                if matches!(self.obj1, Some(_)) {
                    bail!("Obj1 is set twice")
                }
                self.obj1 = Some(v.to_string())
            }
            if OBJ2_ALIASES.iter().any(|alias| &k.to_lowercase() == alias) {
                if matches!(self.obj2, Some(_)) {
                    bail!("Obj2 is set twice")
                }
                self.obj2 = Some(v.to_string())
            }
            if PALETTE_ALIASES
                .iter()
                .any(|alias| &k.to_lowercase() == alias)
            {
                if matches!(self.palette_id, Some(_)) {
                    bail!("Palette is set twice")
                }
                self.palette_id = Some(v.to_string())
            }
            if TILECONFIG_ALIASES
                .iter()
                .any(|alias| &k.to_lowercase() == alias)
            {
                if matches!(self.tileconfig, Some(_)) {
                    bail!("TileConfig is set twice")
                }
                self.tileconfig = Some(v.to_string())
            }
            if MAPID_ALIASES.iter().any(|alias| &k.to_lowercase() == alias) {
                if matches!(self.map_id, Some(_)) {
                    bail!("MapID is set twice")
                }
                self.map_id = Some(v.to_string())
            }
            if ANIMS1_ALIASES
                .iter()
                .any(|alias| &k.to_lowercase() == alias)
            {
                if matches!(self.anims1, Some(_)) {
                    bail!("Anims1 is set twice")
                }
                self.anims1 = Some(v.to_string())
            }
            if ANIMS2_ALIASES
                .iter()
                .any(|alias| &k.to_lowercase() == alias)
            {
                if matches!(self.anims2, Some(_)) {
                    bail!("Anims2 is set twice")
                }
                self.anims2 = Some(v.to_string())
            }
        }

        Ok(())
    }

    pub fn render(&self, map_label: impl AsRef<str>) -> Vec<String> {
        // No chapter ID, nothing to be done
        let chapter_id = match &self.chapter_id {
            None => return vec!["// no chapter id set".to_string()],
            Some(cid) => cid.clone(),
        };

        let mut result: Vec<String> = Vec::new();

        if let Some(obj1) = &self.obj1 {
            result.push(format!("// obj1 = {}", obj1));
        }
        if let Some(obj2) = &self.obj2 {
            result.push(format!("// obj2 = {}", obj2));
        }
        if let Some(palette_id) = &self.palette_id {
            result.push(format!("// palette_id = {}", palette_id));
        }
        if let Some(tileconfig) = &self.tileconfig {
            result.push(format!("// tileconfig = {}", tileconfig));
        }
        if let Some(map_id) = &self.map_id {
            result.push(format!("// map_id = {}", map_id))
        }
        if let Some(anims1) = &self.anims1 {
            result.push(format!("// anims1 = {}", anims1));
        }
        if let Some(anims2) = &self.anims2 {
            result.push(format!("// anims2 = {}", anims2));
        }
        if let Some(map_changes_id) = &self.map_changes_id {
            result.push(format!("// map_changes_id = {}", map_changes_id));
        }

        result.push("{".to_string());
        result.push("PUSH".to_string());
        result.push(format!(
            "EntryBase := ChapterDataTable+({} * ChapterDataTableEntSize)",
            chapter_id
        ));

        if let Some(obj1) = &self.obj1 {
            result.push("// obj1".to_string());
            result.push(format!("ORG EntryBase+4"));
            result.push(format!("BYTE {}", obj1));
        }
        if let Some(obj2) = &self.obj2 {
            result.push("// obj2".to_string());
            result.push(format!("ORG EntryBase+5"));
            result.push(format!("BYTE {}", obj2));
        }
        if let Some(palette_id) = &self.palette_id {
            result.push("// palette_id".to_string());
            result.push(format!("ORG EntryBase+6"));
            result.push(format!("BYTE {}", palette_id));
        }
        if let Some(tileconfig) = &self.tileconfig {
            result.push("// tileconfig".to_string());
            result.push(format!("ORG EntryBase+7"));
            result.push(format!("BYTE {}", tileconfig));
        }
        if let Some(map_id) = &self.map_id {
            result.push("// map_id".to_string());
            result.push(format!("ORG EntryBase+8"));
            result.push(format!("BYTE {}", map_id));
        }
        if let Some(anims1) = &self.anims1 {
            result.push("// anims1".to_string());
            result.push(format!("ORG EntryBase+9"));
            result.push(format!("BYTE {}", anims1));
        }
        if let Some(anims2) = &self.anims2 {
            result.push("// anims2".to_string());
            result.push(format!("ORG EntryBase+10"));
            result.push(format!("BYTE {}", anims2));
        }
        if let Some(map_changes_id) = &self.map_changes_id {
            result.push("// map_changes_id".to_string());
            result.push(format!("ORG EntryBase+11"));
            result.push(format!("BYTE {}", map_changes_id));
        }

        if let Some(map_id) = &self.map_id {
            result.push(format!(
                "EventPointerTable({}, {})",
                map_id,
                map_label.as_ref()
            ))
        }

        result.push("POP".to_string());
        result.push("}".to_string());

        result
    }
}

pub struct Map {
    pub width: usize,
    pub height: usize,
    // use Vec because changes are ordered
    pub changes: Vec<(String, MapChange)>,
    pub properties: Properties,
    tiles: Vec<Tile>,
}

pub struct MapChange {
    pub x: usize,
    pub y: usize,
    pub width: usize,
    pub height: usize,
    tiles: Vec<Tile>,
}

impl Map {
    pub fn new(
        width: usize,
        height: usize,
        changes: impl IntoIterator<Item = (String, MapChange)>,
        tiles: impl IntoIterator<Item = Tile>,
        properties: Properties,
    ) -> Result<Self> {
        let tiles: Vec<_> = tiles.into_iter().collect();

        if tiles.len() != width * height {
            bail!("the provided size of the map does not match the size of the tile data")
        }

        Ok(Self {
            width,
            height,
            changes: changes.into_iter().collect(),
            tiles,
            properties,
        })
    }

    pub fn encode(&self) -> Result<Vec<u8>> {
        let mut result: Vec<u8> = Vec::new();

        if self.width * self.height != self.tiles.len() {
            bail!("BUG: map size does not match internal map data")
        }

        result.push(self.width as u8);
        result.push(self.height as u8);

        for tile in self.tiles.iter() {
            result.extend(tile.0.to_le_bytes());
        }

        Ok(compress(
            &result[..],
            CompressionStrategy::CheckMostRecentOnly,
        ))
    }

    pub fn installer(
        &self,
        map_label: impl AsRef<str>,
        mapchanges_label: impl AsRef<str>,
        dmp_filename: impl AsRef<Path>,
    ) -> Result<Vec<String>> {
        let mut result = MAP2EA_HEADER_LINES
            .iter()
            .map(|s| s.to_string())
            .collect::<Vec<_>>();

        result.push("".to_string());

        // Map data
        result.push("ALIGN 4".to_string());
        result.push(format!("{}:", map_label.as_ref()));
        result.push(format!(
            "#incbin {}",
            dmp_filename.as_ref().to_string_lossy()
        ));
        result.push("".to_string());

        // Map properties
        result.extend(self.properties.render(map_label));
        result.push("".to_string());

        // Map changes
        let mut map_change_names = HashSet::new();
        let mut data_entries: Vec<String> = Vec::new();
        result.push("ALIGN 4".to_string());
        result.push(format!("{}:", mapchanges_label.as_ref()));
        for (i, (name, change)) in self.changes.iter().enumerate() {
            if i > 255 {
                bail!("too many map changes");
            }

            let name = make_identifier(name)?;

            if map_change_names.contains(&name) {
                bail!("duplicate tilechange layer names: {}", name);
            }

            map_change_names.insert(name.clone());
            result.push(change.render_entry(i as u8, &name));
            data_entries.extend(change.render_data(&name));
        }
        result.push("  TileMapEnd".to_string());

        result.push("ALIGN 4".to_string());
        result.extend(data_entries.into_iter());

        if let Some(map_changes_id) = &self.properties.map_changes_id {
            result.push(format!(
                "EventPointerTable({}, {})",
                map_changes_id,
                mapchanges_label.as_ref()
            ));
        }

        Ok(result)
    }
}

impl MapChange {
    pub fn new(
        x: usize,
        y: usize,
        width: usize,
        height: usize,
        tiles: impl IntoIterator<Item = Tile>,
    ) -> Result<Self> {
        let tiles: Vec<_> = tiles.into_iter().collect();

        if tiles.len() != width * height {
            bail!("declared width/height of map change does not match size of tiledata");
        }

        Ok(Self {
            x,
            y,
            width,
            height,
            tiles,
        })
    }

    pub fn render_entry(&self, id: u8, name: impl AsRef<str>) -> String {
        format!(
            "  TileMap({}, {}, {}, {}, {}, {})",
            id,
            self.x,
            self.y,
            self.width,
            self.height,
            name.as_ref()
        )
    }

    pub fn render_data(&self, name: impl AsRef<str>) -> Vec<String> {
        let mut result: Vec<String> = Vec::new();

        result.push("ALIGN 4".to_string());
        result.push(format!("{}:", name.as_ref()));

        let tiles = self
            .tiles
            .iter()
            .map(Tile::render)
            .collect::<Vec<String>>()
            .join(" ");
        result.push(format!("  SHORT {}", tiles));

        result
    }
}

fn make_identifier(name: impl AsRef<str>) -> Result<String> {
    let candidate = name
        .as_ref()
        .chars()
        .map(|c| {
            if c.is_whitespace() {
                Ok('_')
            } else if !c.is_alphanumeric() || c == '_' {
                Err(anyhow!(
                    "found invalid character {} in layer name `{}`",
                    c,
                    name.as_ref()
                ))
            } else {
                Ok(c)
            }
        })
        .collect::<Result<String>>()?;

    Ok(format!("_{}", candidate))
}
